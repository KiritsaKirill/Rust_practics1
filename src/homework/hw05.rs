fn gcd(a: u32, b: u32) -> u32 {
    // Алгоритм Евкліда для знаходження НОД
    let mut x = a;
    let mut y = b;

    // Поки y не стане 0, обчислюємо залишок від ділення
    while y != 0 {
        let temp = y;
        y = x % y; // Залишок від ділення
        x = temp; // Присвоюємо нові значення
    }

    // Повертаємо НОД
    x
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test() {
        let data = [
            ((42, 56), 14), // НОД для 42 і 56
            ((27, 36), 9),  // НОД для 27 і 36
            ((48, 180), 12), // НОД для 48 і 180
            ((81, 27), 27), // НОД для 81 і 27
            ((64, 16), 16), // НОД для 64 і 16
            ((50, 15), 5),  // НОД для 50 і 15
            ((200, 300), 100), // НОД для 200 і 300
            ((13, 7), 1),   // НОД для простих чисел
            ((100, 75), 25), // НОД для 100 і 75
            ((121, 11), 11), // НОД для 121 і 11
        ];

        // Проходимо через всі пари чисел і перевіряємо правильність результату
        for ((a, b), exp) in data.iter() {
            assert_eq!(*exp, gcd(*a, *b)); // Перевіряємо, чи відповідає результат очікуваному
        }
    }
}

fn main() {
    // Приклад для перевірки
    let a = 56;
    let b = 98;

    // Обчислюємо НОД
    let result = gcd(a, b);
    // Виводимо результат
    println!("Найбільший спільний дільник для {} та {}: {}", a, b, result);
}
